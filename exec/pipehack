# This file is part of newrun, copyright Â© 2011, 2012 M. Kristall
#
# This program is free software. You can redistribute it and/or modify it under
# the terms of version 2 of the GNU General Public License (GPL) as published by
# the Free Software Foundation.
#
# This program is distributed WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GPL
# for more details.
#
# You should have received a copy of the GPL with this distribution. If not,
# see <http://www.gnu.org/licenses/>.

## Config variables
# PIPEPATH	name of the pipe file (something like .tremded_pipe?)
# EXECHACK	executor to use for communicating with the server

# Use this if you want to send commands using a fifo (pipe file)

if [[ "$EXEC" != "pipehack" ]]; then
	warn "$_NAME: COMM=pipehack is not valid"
	exit 125
fi

if [[ "$EXECHACK" != "" ]]; then
	include "$_EXECPATH/$EXECHACK"
fi

COMM=pipe

_pipehack_send () {
	if [[ "$EXECHACK" == "" ]]; then
		stringify "$@"
	else
		"$EXECHACK"Cmd "$@"
	fi
}

_pipehack_start () {
	local pid=$PID
	while true; do
		if [ ! -p "$PIPEPATH" ]; then
			mkfifo "$PIPEPATH"
		fi
		while read -r x < "$PIPEPATH"; do
			_pipehack_send "$x"
			y=($x)
			y[0]=$(echo ${y[0]} | tr [A-Z] [a-z])
			if [[ "${y[0]}" == "$QUIT" ]]; then
				break 2
			fi
		done
		if ! kill -0 $pid 2>/dev/null; then
			break 1
		fi
	done
	rm "$PIPEPATH"
	if [[ "$EXECHACK" != "" ]]; then
		"$EXECHACK"Stop "${x:5}"
	fi
}

pipehackStart () {
	local r=127
	if [[ "$EXECHACK" != "" ]]; then
		"$EXECHACK"Start "$@"
		r=$?
	fi
	if (( r == 127 )); then
		EXECHACK=
		_pipehack_start | "$SERVER" "$@" &> /dev/null &
	else
		_pipehack_start &> /dev/null &
		PID=$!
	fi
	disown
	COMM=pipe
	savepid
}

pipehackStartCmd () {
	COMM="$EXEC"
	if [[ "$EXECHACK" != "" ]]; then
		"$EXECHACK"StartCmd
	fi
}

pipehackStop () {
	"$EXECHACK"Stop "$@"
	return $?
}
