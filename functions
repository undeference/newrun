# This file is part of newrun, copyright Â© 2011 M. Kristall

warn () {
	echo "$@" #>&2  stderr gets redirected to /dev/null in most places
}

include () {
	if ! . "$1" 2> /dev/null; then
		warn "$_NAME: could not exec '$1'"
		exit 1
	fi
}

readconfig () {
	EXEC=
	COMM=
	SERVER=
	DEDICATED=
	BASEPATH=
	HOMEPATH=
	GAMENAME=
	ARGS=

	local config="$1"
	include "$_CONFIGPATH/$config"

	local svname="$(basename "$config")"
	PIDFILE="$_PIDPATH/$svname.pid"

	# set up defaults
	if [[ "$SERVER" == "" ]]; then
		SERVER=/usr/local/games/tremulous/tremded.*
	fi
	if [ ! -x "$SERVER" ]; then
		warn "$_NAME: SERVER cannot be used: $SERVER"
		exit 2
	fi
	if [[ "$DEDICATED" == "" ]]; then
		DEDICATED=1
		warn "$_NAME: DEDICATED was not set, running as LAN server"
	fi
	if [[ "$BASEPATH" == "" ]]; then
		BASEPATH="/usr/local/games/tremulous"
	fi
	if [ ! -d "$BASEPATH" ]; then
		warn "$_NAME: BASEPATH does not exist: $BASEPATH"
		exit 2
	fi
	if [[ "$HOMEPATH" == "" ]]; then
		# tremded will create this one
		HOMEPATH="$HOME/.tremulous"
	fi
	if [[ "$PORT" == "" ]]; then
		PORT=30720
	fi
	if [[ "$GAMENAME" == "" ]]; then
		GAMENAME="base"
	fi
	if [[ "$EXEC" == "" ]]; then
		warn "$_NAME: EXEC needs to be specified"
		exit 2
	fi

	include "$_EXECPATH/$EXEC"
	if [[ "$COMM" == "" ]]; then
		COMM="$EXEC";
	else
		include "$_EXECPATH/$COMM"
	fi
}

getpid () {
	PID=
	if [ -f "$PIDFILE" ]; then
		read PID < "$PIDFILE"
	else
		return 1
	fi
}

savepid () {
	if [[ "$PIDFILE" != "" && "$PIDFILE" != "$DEFAULT_PIDFILE" ]]; then
		echo "$PID" > "$PIDFILE"
		chmod 600 "$PIDFILE" &> /dev/null
	fi
}

removepid () {
	rm -f "$DEFAULT_PIDFILE" "$PIDFILE" &> /dev/null
}

pidfilehack () {
	PID=
	if [[ "$DEFAULT_PIDFILE" != "" && -f "$DEFAULT_PIDFILE" ]]; then
		read PID < "$DEFAULT_PIDFILE"
		removepid
	else
		PID=($(pidof "$SERVER"))
		if (( ${#PID[@]} == 1 )); then
			PID="${PID[0]}"
		elif (( ${#PID[@]} > 1 )); then
			PID=-${#PID[@]}
		else
			PID=
		fi
	fi
}

isrunning () {
	if [[ "$PID" == "" ]]; then
		getpid
	fi
	if [[ "$PID" == "" ]]; then
		return 1
	fi
	kill -0 $PID &> /dev/null
	return $?
}

forcequit () {
	if ! isrunning; then
		return
	fi
	sleep 2
	if isrunning; then
		kill -QUIT $PID &> /dev/null
		sleep 1
		if isrunning; then
			warn "$_NAME: server doesn't want to quit"
			kill -KILL $PID &> /dev/null
		fi
	fi
}

countdown () {
	local i=$1
	shift 1
	local s=s
	for (( ; i > 0; i-- )); do
		if (( i == 1 )); then
			s=
		fi
		Cmd cp "^$i$@ in $i second$s"
		sleep 1
	done
}

Cmd () {
	"$COMM"Cmd "$@" 2>/dev/null
	if (( $? == 127 )); then
		"$EXEC"Cmd "$@" 2>/dev/null
	fi
	if (( $? == 127 )); then
		echo "$_NAME: $COMM does not specify a way to communicate" >&2
		exit 1
	fi
}

stringify () {
	local str append
	while (( $# > 0 )); do
		if [[ "$1" =~ [" ;"] ]]; then
			append="\"$1\""
		else
			append=$1
		fi
		if [[ "$str" == "" ]]; then
			str=$append
		else
			str="$str $append"
		fi
		shift 1
	done
	echo "$str"
}

push () {
	local arr="$1"
	shift 1
	eval "$arr=(\"\${$arr[@]}\" \"\$@\")"
}

Start () {
	STARTCMD=(
		+set dedicated "$DEDICATED"
		+set net_port "$PORT"
		+set net_port6 "$PORT"
		+set fs_basepath "$BASEPATH"
		+set fs_homepath "$HOMEPATH"
		+set fs_game "$GAMENAME"
	)
	"$EXEC"StartCmd 2>/dev/null
	if [[ "$COMM" != "$EXEC" ]]; then
		"$COMM"StartCmd 2>/dev/null
	fi
	"$EXEC"Start "${STARTCMD[@]}" "$@" 2>/dev/null
	if (( $? == 127 )); then
		"$SERVER" "${STARTCMD[@]}" "$@" < /dev/null &> /dev/null &
		PID=$!
		disown
		savepid
	fi
}

Stop () {
	"$EXEC"Stop "$@" 2>/dev/null
	if (( $? == 127 )); then
		Cmd quit "$(stringify "$@")" 2> /dev/null
		forcequit
		removepid
	fi
}

Restart () {
	"$EXEC"Restart "$@" 2>/dev/null
	if (( $? == 127 )); then
		if isrunning; then
			countdown 5 Restart
			Stop Please reconnect in a few seconds
			Start "$@"
		else
			warn "$_NAME: server is not running?"
			exit 255
		fi
	fi
}

Reload () {
	if [[ "$@" != "" ]]; then
		Cmd say "$@"
	fi
	countdown 5 Restart
	Cmd "$RELOADCOMMAND"
}
