# This file is part of newrun, copyright Â© 2011, 2012 M. Kristall

preserve () {
	cat
}

upper () {
	tr [a-z] [A-Z]
}

uc () {
	echo "$@" | upper
}

lower () {
	tr [A-Z] [a-z]
}

lc () {
	echo "$@" | lower
}

gv () {
	eval "echo \"\$$1\""
}

sv () {
	eval "$1=\"\$$2\""
}

ev () {
	eval "$1=\"$2\""
}

sa () {
	eval "$1=(\"\${$2[@]}\")"
}

warn () {
	echo "$@" #>&2  stderr gets redirected to /dev/null in most places
}

include () {
	if ! . "$1" 2> /dev/null; then
		warn "$_NAME: could not exec '$1'"
		exit 1
	fi
}

readconfig () {
	local config="$1"
	include "$_CONFIGPATH/$config"
	include "$_DEFPATH/$TYPE"

	local svname="$(basename "$config")"
	PIDFILE="$_PIDPATH/$svname.pid"

	if [[ "$SERVER" == "" ]]; then
		SERVER="$_SERVER"
	fi
	if [ ! -x "$SERVER" ]; then
		warn "$_NAME: SERVER cannot be used: $SERVER"
		exit 2
	fi

	if [[ "$EXEC" == "" ]]; then
		EXEC=null
	fi
	include "$_EXECPATH/$EXEC"

	if [[ "$COMM" == "" ]]; then
		COMM="$EXEC"
	fi
	if [[ "$COMM" != "$EXEC" ]]; then
		include "$_EXECPATH/$COMM"
	fi


	case "$CASE" in
		lower|upper|preserve)
			;;
		*)
			CASE=preserve
			;;
	esac

	if [[ "$ARGDELIM" != "" && ! "$UNSAFE" =~ "$ARGDELIM" ]]; then
		UNSAFE="$UNSAFE$ARGDELIM"
	fi

	case "$QUOTE" in
		escape)
			if [[ "$ESCAPE" == "" ]]; then
				ESCAPE=\\
			fi
			if [[ ! "$UNSAFE" =~ "$ESCAPE" ]]; then
				UNSAFE="$UNSAFE$ESCAPE"
			fi
			;;
		single)
			QUOTE="'"
			;;
		double|*)
			QUOTE='"'
			;;
	esac

	init
}

getpid () {
	PID=
	if [ -f "$PIDFILE" ]; then
		read PID < "$PIDFILE"
	else
		return 1
	fi
}

savepid () {
	if [[ "$PIDFILE" != "" && "$PIDFILE" != "$DEFAULT_PIDFILE" ]]; then
		echo "$PID" > "$PIDFILE"
		chmod 600 "$PIDFILE" &> /dev/null
	fi
}

removepid () {
	rm -f "$DEFAULT_PIDFILE" "$PIDFILE" &> /dev/null
}

pidfilehack () {
	PID=
	if [[ "$DEFAULT_PIDFILE" != "" && -f "$DEFAULT_PIDFILE" ]]; then
		read PID < "$DEFAULT_PIDFILE"
		removepid
	else
		PID=($(pidof "$SERVER"))
		if (( ${#PID[@]} == 1 )); then
			PID="${PID[0]}"
		elif (( ${#PID[@]} > 1 )); then
			PID=-${#PID[@]}
		else
			PID=
		fi
	fi
}

isrunning () {
	if [[ "$PID" == "" ]]; then
		getpid
	fi
	if [[ "$PID" == "" ]]; then
		return 1
	fi
	kill -0 $PID &> /dev/null
	return $?
}

forcequit () {
	if isrunning; then
		sleep 1
		if ! isrunning; then
			return
		fi
			kill -TERM $PID &> /dev/null
		sleep 1
		if isrunning; then
			warn "$_NAME: server doesn't want to quit"
			kill -KILL $PID &> /dev/null
		fi
	fi
}

stringify () {
	local str append arg i
	while (( $# > 0 )); do
		arg="$1"
		shift 1
		if [[ "$QUOTE" == escape ]]; then
			for (( i = 0; i < ${#arg}; i++ )); do
				if [[ "${arg:i:1}" =~ ["$UNSAFE"] ]]; then
					append="$append$ESCAPE${arg:i:1}"
				else
					append="$append${arg:i:1}"
				fi
			done
		else
			if [[ "$arg" =~ ["$UNSAFE"] ]]; then
				append="$QUOTE$arg$QUOTE"
			else
				append="$arg"
			fi
		fi
		if [[ "$str" == "" ]]; then
			str="$append"
		else
			str="$str$ARGDELIM$append"
		fi
	done
	echo "$str"
}

push () {
	local arr="$1"
	shift 1
	eval "$arr=(\"\${$arr[@]}\" \"\$@\")"
}

## flags
F_SKIP=1	# skip
F_NOARG=2	# no arguments
F_NOPRE=4	# no PREFIX
F_NOVAL=8	# no value
F_NODEF=16	# no default value
init () {
	local flags typ varname val arg def opt i
	for (( i = 0; i < ${#ARGUMENTS[@]}; )); do
		opt=()
		flags=0
		def=
		typ="${ARGUMENTS[i++]}"
		varname="${ARGUMENTS[i++]}"
		sv val "$varname"
		if [[ "$val" == "" ]]; then
			(( flags |= F_SKIP ))
		fi
		case "$typ" in
			req)
				(( flags |= ( F_NOPRE | F_NODEF ) ))
				;;
			bool)
				(( flags |= ( F_NOVAL | F_NODEF ) ))
				if [[ "$val" == "0" ]]; then
					(( flags |= F_NOARG | F_SKIP ))
				fi
				;;
			int)
				val="$(echo "$val" | tr -d '[\0-/:-\xff]')"
				if [[ "$val" == "" ]]; then
					(( flags |= F_SKIP ))
				fi
				;;
			file)
				if (( !( flags & F_SKIP ) )) && [ ! -f "$val" ];
				then
					echo "$val is not a file" >&2
		#			exit 12
				fi
				;;
			dir)
				if (( !( flags & F_SKIP ) )) && [ ! -d "$val" ];
				then
					echo "$val is not a directory" >&2
		#			exit 12
				fi
				;;
			str|*)
				;;
		esac
		# default value
		if (( !( flags & ( F_NOVAL | F_NODEF ) ) )); then
			def="${ARGUMENTS[i++]}"
			if [[ "$val" == "" ]]; then
				ev "$varname" "$def"
				val="$def"
			fi
			if [[ "$val" == "$def" ]]; then
				# don't process args/value
				(( flags |= ( F_SKIP | F_NOARG ) ))
			fi
		fi
		# args
		if (( !( flags & F_NOARG ) )); then
			arg="${ARGUMENTS[i++]}"
			if (( !( flags & F_NOPRE ) )); then
				arg="$PREFIX$arg"
			fi
			push opt "$arg"
			for (( ; i < ${#ARGUMENTS[@]}; i++ )); do
				arg="${ARGUMENTS[i]}"
				if [[ "$arg" == + ]]; then
					break 1
				fi
				push opt "$arg"
			done
			# value
			if (( !( flags & F_NOVAL ) )); then
				if [[ "$EQUALS" != "" ]]; then
					(( arg=${#opt[@]} - 1 ))
					opt[arg]="${opt[arg]}$EQUALS$(stringify "$val")"
				else
					push opt "$val"
				fi
			fi
		fi
		for (( ; i < ${#ARGUMENTS[@]}; i++ )); do
			if [[ "${ARGUMENTS[i]}" == + ]]; then
				(( i++ ))
				break
			fi
		done
		# need to add value here
		if (( !( flags & F_SKIP ) )); then
			push run "${opt[@]}"
		fi
	done
}

Cmd () {
	"$COMM"Cmd "$@" 2>/dev/null
	local r=$?
	if (( r == 127 )) && [[ "$COMM" != "$EXEC" ]]; then
		"$EXEC"Cmd "$@" 2>/dev/null
		r=$?
	fi
	if (( r == 127 )); then
		echo "$_NAME: $COMM does not specify a way to communicate" >&2
		exit 1
	fi
}

Start () {
	STARTCMD=()
	"$EXEC"StartCmd 2>/dev/null
	if [[ "$COMM" != "$EXEC" ]]; then
		"$COMM"StartCmd 2>/dev/null
	fi
	"$EXEC"Start "${run[@]}" "${STARTCMD[@]}" "$@" 2>/dev/null
	if (( $? == 127 )); then
		"$SERVER" "${run[@]}" "${STARTCMD[@]}" "$@" \
			< /dev/null &> /dev/null &
		PID=$!
		disown
		savepid
	fi
}

Stop () {
	"$EXEC"Stop "$@" 2>/dev/null
	if (( $? == 127 )); then
		if ! isrunning; then
			warn "$_NAME: server may not be running"
			exit 255
		fi
		Cmd $QUIT "$(stringify "$@")" 2> /dev/null
		forcequit
		removepid
	fi
}

Restart () {
	"$EXEC"Restart "$@" 2>/dev/null
	if (( $? == 127 )); then
		if ! isrunning; then
			warn "$_NAME: server may not be running"
			exit 255
		fi
		Stop Please reconnect in a few seconds
		Start "$@"
	fi
}

Reload () {
	Restart
}
